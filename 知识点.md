# vue UI design

#### 介绍

vue组件化设计，实现自己的组件库

- 有反馈
- 一致性
- 可预测
- 如表单提交：1.用户点击tab有反馈，回车也要反馈 2.用户点击提交，按钮变成disabled或者loading 3.如果确定放在左边，取消放右边，就要一直坚持 4.用户提交后出错，已经填写内容不能丢弃

#### 按钮组件

1.按钮状态

- 点击->不可点击->loading->点击....
- 点击，hover，按下

2.使用组件时候box-sizing:border-box

3.parcel-bundler 轻量打包工具

- css标量  

  - ```css
    //index.html
    :root{
        --button-height:36px;
    }
    //button.vue
    .w-button{
       height: var(--button-height);
    }
    ```

- 有个src/app.js  src/.vue文件

- 根目录下面 index.html (script src="./src/app.js")

  - ```html
    <body>
        <div id="app">
        </div>
    </body>
    <script src="./src/app.js"></script>
    ```

  - 

- app.js  

  - ```js
    import Vue from 'vue'
    import Button from './src/button'
    Vue.component('w-button',Button)
    new Vue({
        el:'#app'
    })
    ```

- ./src/button.vue

  - ```js
    template
    script
    style
    ```

- 改为单文件.vue形式

- ```cnpm i -D parcel-bundler@1.9.2```

- ```
  yarn add -D vue-template-compiler @vue/component-compiler-utils vue-hot-reload-api node-sass
  ```

- package.json里面加入

  - ```json
    "alias":{
        "vue":"./node_modules/vue/dist/vue.common.js"
    }
    ```

4.can i use查看兼容问题

5.git open 直接打开github项目

6.npx parcel --no-cache(删除cache)  执行parcel



#### 知识点

- 工具 了解

  - webpack
  - parcel
  - scss less babel

- 语言特征 深入

  - Promise
  - async 

- 抽象

- 代码组织-流程-设计模式

- iconfont使用

  - ```
    //at.alicdn.com/t/font_1553596_xne184iwzaj.js
    ```

  - 作为symbol使用

  - ```html
    <svg class="icon">
        <use :xlink:href="`#wicon-${icon}`"></use>
    </svg>
    ```

- 属性检查器 validator

  - ```js
    props:{
        icon:{},
            iconPosition:{
                type:String,
                    default:'left',
                        validator(value){
                        if(value!=='left'&& value!=='right'){
                            return false
                        }else{
                            return true
                        }
                    }
            }
    }
    ```



#### 按钮组件设计

1.svg,icon 设计成一个组件

2.loading添加点击

- loading按钮是自定义组件 点击事件1.加native修饰符 表示点击这个组件 2.子组件父组件$emit传递



#### 测试

BDD 行为驱动开发

TDD 测试驱动开发

assert 断言

1.单元测试  chai.expect

```js
import chai from 'chai'
const expect = chai.expect
{
    const Constructor = Vue.extend(Button)
    const button = new Constructor({
        propsData:{
            icon:'personnone'
        }
    })
    //单元测试 看输入的是否匹配
    button.$mount("#test")
    let useElement = button.$el.querySelector('use')
    let href = useElement.getAttribute('xlink:href')
    expect(href).to.eq('#wicon-personnone')
}
```

2.chai.spy监听回调函数

home键到最前面

#### 使用karma+mocha单元测试

打包js-打开浏览器-关闭浏览器结果反馈出来

BDD describe it

https://www.jianshu.com/p/d7640c1836d0

karma:引入基础的库，打开浏览器，引入了测试用例dist/test...

mocha:describe函数

sinon-chai:sinon.fake命令,chai提供了calledWith



#### 上传到npm

1.新建index.js

- 导出需要上传的组件 import export

2.package.json 

- 增加入口"main": "index.js"

3.npm adduser

4.淘宝镜像改动 npm config list

5.Logged in as...登录成功

6.npm publish

7.删除 npm unpublish vue-ui-design-test --force

8.发布的文件有import export、node不支持，使用者需要用babel编译

9.自己编译之后再发布 npx parcel build index.js --no-cache --no-minify

10.编译之后 package.json路径改一下 

- 增加入口"main": "dist/index.js"

11.npm link 本地更新不用publish

12.各个组件里面需要改成局部组件引入，不要全局引入vue.component

#### 加上标志

https://shields.io/category/build

#### 阿里字体库自动引入

svg.js里面贴入//at.alicdn.com/t/font_1553596_ubo3p9t0gjp.js

#### 代码回滚

git log 找到commit的序号
git reset --hard commit的序号
git show commit的序号 查看变更



#### 输入框

如果选择的是多色图标且下载到本地的话，默认是带有颜色的需要修改的话，需要在编译器里面打开svg  然后将fill属性制空即可，然后在需要的时候使用css 例如svg {fill:red}即可填充颜色。当然有些图标没有fill属性的话是可以直接修改的

- 常见状态 hover focus error 

- v-model原理

  - ```html
    <input type="text" v-model="message">
    <input type="text" :value="message" 
           @input="message=$event.target.value">
    
    ```

  - 让自己的组件支持v-mode语法糖

  - 1.子组件中的input 有

    - ```html
      <input type="text" :value="value" 
             @input="$emit('input',$event.target.value)">
      
      ```

  - 2.定义组件的地方

    - ```html
      <w-input v-model="message">
      
      ```

      

#### git操作分支

在master分支上分出新的分支，会复制master的所有git log的记录
1.git branch button-and-input  
只是新建了一个分支，没有切换到那个分支，继续在master分支上
去提交东西
继续在当前master上去git add/git commit/git push
2.git push origin button-and-input:button-and-input
将这个分支提交到远程去，这样这个分支上市git branch创建时候的
git log的所有记录
2.git checkout button-and-input

#### vue父子之间钩子顺序

created 创建组件对象
mounted 挂载了组件
有父子组件的时候 created mounted顺序
parent created
child created
child mounted
parent mounted 

#### 手动测试

#### 加入响应式

页面变化的时候，比例会变化
1.一开始4:20 后来12：12

```html
<w-row>
    <w-col span="4"></w-col>
    <w-col span="20"></w-col>
</w-row>
<!-- 改变之后 -->
<w-row>
    <w-col span="12"></w-col>
    <w-col span="12"></w-col>
</w-row>

<w-row>
    <!-- 这样不可取 phone-span要对应offset-phone-span -->
    <w-col span="4" phone-span=""></w-col>
    <w-col span="20"></w-col>
</w-row>

<w-col phone="{span:4,offset:1}"></w-col>

```

有几种设备,默认是什么设置就删除哪一种设置
phone,ipad,narrow-pc,pc
Mobile First 移动端有限 往移动端走
各个区域写样式
如果有样式没有写 要确保有默认样式
没有写对应的屏幕的类的时候，默认是离他最近的那个

> 576 的时候运用手机样式
> 768
> 992
> 1200
> 0-576
> 576-768
> 768-992
> 992-1200

####  

window下面做karma测试跑两个终端
测试用例里面存在异步代码
参数里面要传入done
 it(''.(done)=>{})

```js
// vue的dom是异步操作
var div = document.createElement("div")
var div2 = document.createElement("div")
var child = document.createElement("div")
div.appendChild(child) //mounted1钩子函数
div2.appendChild(div) //mounted2钩子函数
//这两个钩子函数放到一个异步队列里面 等到同步都执行完毕才去执行异步
console.log(div.outerHTML);//这个执行实在mounted1 mounted2都执行完毕才去执行
//将div.outerHTML setTimeout变成异步代码 这样会推到mounted1 mounted2之后 异步队列里面

```



#### toast

1.弹出toast-自动关闭-点击关闭-同时只有一个

2.vue.prototype.$toast

- 不知道全局有没有$toast这个变量，有的话被覆盖了
- 侵入性太强

3.vue.extend创建的是组件构造器

4.创建插件的步骤

- 定义插件 

  - ```js
    //plugin.js
    import 'toast' from './toast'
    export default{
        install(Vue,options){
            Vue.prototype.$toast = function(message){
                let Constructor = Vue.extend(toast)
                let toast = new Constructor()
                toast.$slots.default = [message]
                toast.$mount()
                document.body.appendChild(toast)
            }
        }
    }
    
    //app.js
    import plugin from './plugin'
    Vue.use(plugin)
    
    ```

  - 





#### Vue和vue-template-compiler版本之间的问题

npm update

#### 一些bug

1.github警告：依赖的包可能有问题
2.parcel watch test/* --no-cache & karma start
&在window下不支持 
先运行第一个，再运行第二个
3.bug定位
1.查改大概位置 2.二分法

#### tab

需求分析
UI
代码
测试

1.切换tab,tab有icon,横竖tab,右侧加按钮,
2.结构，为了nav层和content层分离

```html
<w-tabs>
    <w-tabs-nav>
        <w-tabs-item name="tab1">1</w-tabs-item>
        <w-tabs-item name="tab2">2</w-tabs-item>
    </w-tabs-nav>
    <w-tabs-content>
        <w-tabs-pane name="tab1">1</w-tabs-pane>
        <w-tabs-pane name="tab2">2</w-tabs-pane>
    </w-tabs-content>
</w-tabs>

```

语法糖.sync

```
<w-tabs :selected="selectedTab" 
            @update:selected="selectedTab = $event">
<w-tabs :selected.sync="selectedTab">

```

3.存在爷父子三层通信，使用事件总线EventBus
发布事件，所有组件订阅
爷爷身上加上属性 provide:{eventBus:}
任何后代都可以访问 后代inject注入
this.$emit和this.eventBus.$emit()
vue的事件系统不会冒泡 孙->子->父，哪个地方调用 哪个地方监听

```js
//parent
data(){
    return {
        eventBus:new Vue()
    }
},
provide(){
    return {
        eventBus:this.eventBus
    }
},
created(){
    this.eventBus.$emit('updated:selected','ceshi')
}

//child son
inject:['eventBus'],
created(){
    this.eventBus.$on('update:selected',(name)=>{})
}

```

4.style class会默认合并

#### popover

1.如果弹出层和按钮在同一个层级，外一最外层overflow hidden
2.按钮点击冒泡 阻止冒泡 每一个点击上面加上修饰符.stop?
但是别人用了组件，会将别人的绑定事件给阻止

```html
<div @click>
    <component></component>
</div>

```

关闭重复-> 分开职责，document只管外部，popover只管里面
3.忘记取消监听document->收拢close
4.扩展
作用域插槽要求，在slot上面绑定数
user是child里面传入的数据，可以直接使用这个数据
但是形式为 

```html
 <child>
    <template slot-scope="user">
    <div class="tmpl">
        <span v-for="item in user.data">{{item}}</span>
    </div>
    </template>

</child>

//子组件
<template>
  <div class="child">

    <h3>这里是子组件</h3>
    // 作用域插槽
    <slot :data="data"></slot>
  </div>
</template>

```

#### collapse

父最后传递给最外层通过$emit
单向数据流
在父上传递更新事件，只是负责传递
在子级上传递通知事件
单向传递
测试
1.单一层级组件
2.嵌套组件

#### 设计模式

1.发布订阅
发布/订阅/发布中心 中心事件处理
2.单向事件流

#### vuepress

1.创建

```bash
# 安装
yarn global add vuepress # 或者：npm install -g vuepress

# 创建项目目录
mkdir docs && cd docs

# 新建一个 markdown 文件
echo '# Hello VuePress!' > README.md

# 开始写作
vuepress dev .

# 构建静态文件
vuepress build .

```

2.package.json创建脚本运行

```json
"docs:dev":"vuepress dev docs",
"deovs:build":"vuepress build docs"

```

3.docs下创建多个目录

- 1.get-started / README.md
- 2.install / README.md , windows.md , macos.md
  4.配置文件
  docs下面
  .vuepress/config.js

```js
module.exports = {
    title: 'WUI',
    description: 'A Vuejs Framework',
    themeConfig: {
        nav: [
            { text: '主页', link: '/' },
            { text: '文档', link: '/guide/' },
            { text: '交流', link: '/' },
        ],
        sidebar: [
            '/',
            '/install/',
            '/get-started/'
          ]
    }
    
  }

```

5.目录下面修改文件
/get-started/README.md
一定要加上---和title这个符号

```bash
---
title: 快速上手
---

# 快速上手

```

6.文档中使用组件
建立文件夹
.vuepress/components/button-demos.vue

7.render function or template not defined in component: button-demos
思路：
1)删代码，最简单组件能成功
2)得到能用的版本加代码
3)import button 找到问题
比如问题：只要beforeMount或者mounted访问浏览/dom的api
要么就加上<ClientOnly>
8.部署
docs/.vuepress/config.js修改base:'/自己的项目地址/',如 /WUI/

deploy.sh
https://github.com/weizaicv/WUI
https://weizaicv.github.io/WUI

9.部署到其他地方
config.js改下base配置build一下将dist目录中的东西放入其他仓库

10.import Prism from "prismjs";
代码显示高亮
mounted() {
    //主题css，可自选
    Prism.highlightAll()
}

#### scss

mixin
.a{} .b{} .c{}
palceholder
.a,.b,.c{}

#### 升级单元测试

1.报错

TypeError: Cannot read property 'getAttribute' of undefined

svg.js

```js
var scripts = document.getElementsByTagName("script");var script = scripts[scripts.length-1];if(!script){return};

```

指令专门封装dom操作



#### 面试题

```js
for(
let i = (setTimeout( ()=>console.log(i),2000), 0);
    i<2;
    i++
){
    console.log(i)
}

```



#### 省市区！

cascader-item递归组件

自己调用自己，并且有结束的条件

分成left right （left right(left right(left right))）的形式

1.分成左边和右边的布局，右边继续调用当前组件分成左边和右边

计算属性rightItems为结束条件

2.每次必须改变所有dom，改为单向数据流，所有change之后的数据告诉最顶层，最顶层来改变视图，最顶级selected:[]选中的

3.bug

提示codejs问题，安装vue-cli3.4版本

```bash
vue-cli3.0升级失败，vue-cli卸载不掉，vue-cli升级不了3.0，

原文在:https://juejin.im/entry/5bf7e88851882521c811423e

升级个vue-cli3.0，真的差点气死我了！一直卸载不掉!

我差一点就重装电脑了！百度，google翻了个底操天也没找到解决办法！最后放弃百度自己重头开始研究自己到底哪一步出错了！

所以我把自己遇到的问题，以及如何解决的告诉大家，避免想我一样的人再步入我的后路！

升级途中遇到的问题:

#### 1.$npm uninstall vue-cli -g      //卸载vue-cli旧版本</br>

#### 2.$npm install -g @vue/cli      //安装新版本</br>

#### 3.$npm vue -V                  //2.9.6,我差，根本没删除掉！</br>

重复上面操作很多次都一样！心态爆炸了！难受！

解决:

原因: npm install -g @vue/cli 后， 我发现在C:\Users\Administrator\AppData\Roaming\npm\node_modules目录下多了一个@vue的文件夹。也就是说全局安装的文件都在这里！ 同时，npm uninstall vue-cli -g 也是删除的这里面的文件。

处理：以我自己的安装目录为例子，我的node安装在D:\Develo\中

1.打开环境变量>在用户变量中找到path,这里的的路径必须和你电脑 npm 的全局安装路径对应，

原来我的之前路径写错了，所以就默认帮我装在C:\Users\Administrator\AppData\Roaming\npm中！ 现在我决定指定这个路径在D:\Develo\nodejs\node_global中（这里的node_global文件夹是我自己新建的）

2.接下来还有一点！系统变量中的NODE_PATH的路径必须和你是 npm 全局安装路径下的 node_modules,所以我这里填写的是D:\Develo\nodejs\node_global\node_modules

3.设置 npm 的默认安装路:

$npm config set prefix "D:\Develo\nodejs\node_global" //这里的路径必须是上面path对应！

$npm config set cache "D:\Develo\nodejs\node_cache"  //---这里是我自定义的缓存路径，无关紧要

4.大功告成了:

重新卸载旧版本，安装新版本启动吧！哈哈！

注意：

1.之前 node 的安装我是参考了 https://www.cnblogs.com/zhouyu2017/p/6485265.html 这位大神的教程

2.C:\Users\Administrator\AppData\Roaming\npm，，一般安装时，没修改 node 安装路径，默认的 npm 全局安装路径就在这里


```

4.加入数据库之后，修改ajax为promise用法；

用户点击北京，找到北京对应的区，然后放入北京的children，实现二级的渲染，主要放入children的时候需要用$set

```bash
@update:selected="xxx"
  //用户点击北京，找到北京的id对应的区，放入北京的source的children里面，实现二级的渲染
  xxx(newSelected){
  	ajax(newSelected[0].id).then(result=>{
  	let last = this.source.filter(item => item.id === newSelected[0].id)[0]
 	 //一开始没children现在有children，对数组修改用set
 	 this.$set(last,'children',result)
 	 // last.children = result
  })

```

5.改进：

将一系列自己做的事情交给组件去做，调用回调函数loadData既可以

```js
 onUpdateSelected(newSelected){
     this.$emit("update:selected",newSelected)
     let lastItem = newSelected[newSelected.length - 1]
     let updateSource = (result)=>{
         let toUpdate = this.source.filter(item=>item.id === lastItem.id)[0]
         this.$set(toUpdate,'children',result)
     }
     this.loadData(lastItem,updateSource)
 }

```



广度优先（先找一个根根）vs深度优先（先找一个根找到没有根为止，每次能有多往下就多往下）



6.由于存在多层级，分成简单算法和复杂算法，分治法

```js

```



7.rightItems没有变化

computed逻辑：必须依赖的值发生变化才变化

```js
  rightItems(){
      let currentSelected = this.selected[this.level]
      if(currentSelected && currentSelected.children){
          return currentSelected.children
      }else{
          return null
      }
  }
```

这里的selected的children没有值，只是从source里面去更新children

computed有缓存UI

单向数据流selected source做为最顶层的变化，cascaderItem(cascaderItem)递归组件



8.增加是否isLeaf有叶子节点 （是否有children） true/false

```js
result.forEach(node=>{
    if(db.filter(item=>item.parent_id==node.id).length>0){
        node.isLeaf = false
    }else{
        node.isLeaf = true
    }
})
```



9.指令



#### 单元测试

1.svg的引入问题

2.yarn run test:unit --watch 

边写边测试

3.跟样式有关的需要配合浏览器，因为原本在内存中是看不到样式的

vue unit test + karma

1) 安装依赖

```
yarn add -D karma karma-chrome-launcher karma-mocha karma-sourcemap-loader karma-spec-reporter karma-webpack chai sinon sinon-chai
```

2) karma配置文件 需要读取默认的webpack配置

```js
var webpackConfig = require('@vue/cli-service/webpack.config.js')
const path = require('path')

module.exports = function (config) {
  config.set({
    frameworks: ['mocha'],

    files: [
      'tests/**/*.spec.js'
    ],

    preprocessors: {
      '**/*.spec.js': ['webpack', 'sourcemap']
    },

    webpack: webpackConfig,

    reporters: ['spec', 'coverage'],
    coverageReporter: {
      dir: './coverage',
      reporters: [
        { type: 'lcov', subdir: '.' },
        { type: 'text-summary' }
      ]
    },
    autoWatch: true,

    browsers: ['ChromeHeadless']
  })
}
```



#### 动画

1.记住四个

第一帧：-enter,-enter-active

第二帧：-enter变为-enter-to

结束：-enter,-enter-active,-enter-to全部消失

一般情况：enter-to，leave 不需要写，代表的是初始状态

```css
.slide-fade-enter-active{
    transition:all 3s ease;
}
.slide-fade-leave-active{
    transition:all 1s cubic-bezier(1.0,0.5...)
}
.slide-fade-enter,.slide-fade-leave-to{
    transform: translateX(10px);
    opacity:0;
}
```

2.animation

一般配合animate.css

```html
<div>
    <button @click="show = !show">
        toogle
    </button>
    <transition name="bounce">
    	<p v-if="show">
            showme
        </p>
    </transition>
</div>
<style>
    .bounce-enter-active{
        animation:bounce-in .5s;
    }
     .bounce-leave-active{
        animation:bounce-in .5s reverse;
    }
    @keyframes bounce-in{
        0%{ transform:scale(0)}
        50%{ transform:scale(1.5)}
        100%{ transform:scale(1)}
    }
</style>
```

配合animate.css使用

```bash
npm install animate.css --save
```

```js
//main.js中：

import animated from 'animate.css' // npm install animate.css --save安装，再引入

Vue.use(animated)
```

```html
<transition
enter-active-class="animated bounceInDown"
leave-active-class="animated bounceOutRight"
>
    <p v-if="showme">show me</p> 
</transition>
```

3.js操作动画

有动画钩子 + velocity

velocity  注意版本1.x

4.多个元素动画

必须加上key 

mode表示动画先后顺序，不要同时进行 out-in/in-out

```vue
<template>
  <div id="app">
    <transition name="fade" mode="out-in">
      <button key="on" v-if="status=='off'" @click="status='on'">on</button>
      <button key="off" v-if="status=='on'" @click="status='off'">off</button>
    </transition>
    
  </div>
</template>
<script>
export default {
  name: "apptest",
  data(){
    return {
      status:'on'
    }
  }
};
</script>
<style lang="scss">
.fade-enter-active,.fade-leave-active{
  transition: all .5s;
}
.fade-enter,.fade-leave-to{
  opacity: 0;
}
</style>
```

5.component

```vue
<button @click="view='v-a'">A</button>
<button @click="view='v-b'">B</button>
<component :is="view"></component>
<script>
export default{
	data(){
        return {
            'view':'v-a'
        }
    },
    components:{
        'v-a':{template:"<div>v-a</div>"},
        'v-b':{template:"<div>v-b</div>"}
    }
}
</script>
```



#### 无缝轮播

1.代替直接操作dom的形式

```vue
<div ref="parent">
    <slot></slot>
</div>
<script>
export default{
    mounted(){
        this.$refs.children();//这样得到三个dom 不合适
    }
}
</script>
```



2.改为组件的形式

```vue
<g-slides>
	<g-slides-item>
        <div class="box">1</div>
    </g-slides-item>
    <g-slides-item>
        <div class="box">2</div>
    </g-slides-item>
</g-slides>
```



3.slides

1.操作dom不符合mvvm思想，操作数据

2.两个组件 slides slides-item

3.slides-item轮播的图片选项：定义props name表示轮播名称

4.定义data selected(控制哪一个轮播进行显示) reverse(正向还是反向)

5.计算属性visible 外部slides随时去改变selected的值 this.selected==this.name控制哪一张轮播显示

6.动画样式  其中slide-leave-active 离开的时候一定要撑开整个盒子 防止塌陷

进入的时候在右侧translateX(100%)->左侧0 反向则相反

```css
.slide-leave-active{
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
}
.slide-enter-active,.slide-leave-active{
    transition: all .5s;
}
.slide-enter{
    transform: translateX(100%);
}
.slide-enter.reverse {
    transform: translateX(-100%);
}
.slide-leave-to {
    transform: translateX(-100%);
}
.slide-leave-to.reverse {
    transform: translateX(100%);
}
```





两部分：图片，技术点

支持手机上的触发



#### 配置公共路径

```js
const path = require('path')
module.exports = {
  css: {
    loaderOptions: {
      sass: {
        sassOptions: {
            indentWidth: 4,
            includePaths: [path.join(__dirname, 'styles')],
          }
      },
    }
  },
}
```

//这样这个路径下面的都可以自动载入

//@import '_var.scss' 等同于直接加载styles下面的文件





#### NAV

v-if 造成destroy组件，什么时候created 用v-show

先后顺序：如果用v-if 

nav监听nav-item点击事件之后才有 生成了 nav-item节点

如果用v-show

nav监听nav-item和nav-item节点同时进行

1.v-if让元素出现/消失在页面中

v-show 一直在页面中 style

v-if true->create 	false->destroy

2.三个组件

nav nav-item sub-nav

3.支持任意层级：用依赖注入

每次加入一个层级，层级中有item就addItem

4.namePath定义在nav组件中，共享给nav-item和sub-nav使用



#### validator

xit 关闭测试

1.代码优化 测试驱动开发

2.共用的 原型上写



#### page

1.can i use查询 MDN查询是否可以用的api

2.reduce拼接...

3.提交版本错误了?

+ 1.通过`git log`查看提交信息，以便获取需要回退至的版本号。
+ 2.git reset –soft <版本号>重置至指定版本的提交，达到撤销提交
+ 3.git push –force



#### table

1.功能

+ 展示数据（带边框，单双）

  + slot-scope  子组件slot 里面的东西传递给外部父组件

+ 选中数据（单选，全选）

  + 单向数据流 props selectedItems表示选中的 需要拷贝一份props数据
  + dataSource 一定有唯一标识Key或者id  判断是否选中SelectedItems.indexOf(item) 不可以 因为selectedItems是深拷贝之后的数据 跟item不是同一个数据里面的，要用唯一标识去寻找 id filter
  + 选中一半半选  indeterminate js控制
  + v-for加上key （全选和反选中删除的bug）
    + 都是深拷贝 只能通过id去搜索对象
    + vue的更新机制 要加上id
    + key要是唯一的id，一定不能用index作为key，删除之后index还是从0开始的
    + 防止vue不知道新的结果和旧的结果之前的关联，给每一项一个唯一的关联，就知道以前的项在不在，现在的项在不在
    + 不加的话 三个li 删除其中一个 vue不知道是将第一个变成第二个，还是删除第一个 index 0 1 2    =>   index 0  1，会认为删除了第三个，加上了Key的话 key 0 1 2   =>   key 1  2 ，就知道0 没了删除了第一个

+ 展示排序

+ 固定表头/列

  + 思路：为了不整体滚动，头部thead需要固定，但是table是一个整体，将table复制一份，删除tbody部分就剩下thead了？复制之后，事件没了，  
  + ie中有点问题 滚动条

+ 可展开

  + expand:false是否展开
  + 用户数据 and UI数据  一定要分开，万一涉及到提交呢

+ 遇到最难的技术问题-----table!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  + 1.th 固定的问题sticky
  + 2.宽度的问题  resize之后还可以继续改变

+ 插槽和子组件

  + ```bash
    $children   (组件里面必须用<slots></slots>之后才能用)
    $slots 获取到所有的插槽
    ```

  + 

weizai

weizai07......

2.vue vs react

























